<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Infinite Cartoon Street (Seamless)</title>
  <style>
    html,body{margin:0;height:100%;background:#0b0d12;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    .spacerTop,.spacerBottom{max-width:900px;margin:0 auto;padding:46px 18px;opacity:.92}
    .spacerTop h1{margin:0 0 10px 0;font-size:clamp(26px,5vw,44px);letter-spacing:-.02em}
    .spacerTop p,.spacerBottom p{margin:0;line-height:1.45;opacity:.85}
    .scrollSection{height:120000px; position:relative;}
    .stage{position:sticky; top:0; height:100svh; width:100%; overflow:hidden; background:#070a10;}
    canvas{display:block;width:100%;height:100%}
    .hud{
      position:absolute; left:50%; top:12px; transform:translateX(-50%);
      width:min(92vw,900px);
      padding:10px 12px; border-radius:14px;
      background:rgba(0,0,0,.30);
      backdrop-filter:blur(10px);
      -webkit-backdrop-filter:blur(10px);
      box-shadow:0 18px 60px rgba(0,0,0,.45);
      pointer-events:none;
    }
    .hud .k{font-size:12px;letter-spacing:.16em;text-transform:uppercase;opacity:.75;margin-bottom:6px}
    .hud .t{margin:0 0 4px 0;font-size:clamp(16px,3.7vw,22px);letter-spacing:-.02em}
    .hud .s{margin:0;font-size:clamp(13px,3.2vw,15px);opacity:.85;line-height:1.35}
  </style>
</head>
<body>

  <div class="spacerTop">
    <h1>Infinite Cartoon Street (Seamless)</h1>
    <p>Scroll down. Seamless loop, spaced houses and lamps, wider grass, higher sky, stronger horizon perspective.</p>
  </div>

  <section class="scrollSection" id="scrollSection">
    <div class="stage">
      <canvas id="c"></canvas>
      <div class="hud">
        <div class="k">Seamless Loop • Clean Spacing • Mobile-first</div>
        <h2 class="t">Scroll to move forward</h2>
        <p class="s">Next: swap drawn houses for AI PNG sprites for a premium cartoon look.</p>
      </div>
    </div>
  </section>

  <div class="spacerBottom">
    <h2 style="margin:0 0 10px 0;">After the scene</h2>
    <p>Normal content continues here.</p>
  </div>

<script>
(() => {
  const section = document.getElementById("scrollSection");
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize);
  resize();

  // ========= Art-directed tuning =========
  const FAR_Z = 5200;             // farther world -> tighter horizon depth
  const NEAR_Z = 120;             // when objects pass near this, recycle
  const SPAN_Z = FAR_Z;           // seamless loop span (exact repeat length)

  const SPEED = 1.85;             // forward speed
  const CURVE = 0.00045;          // gentle road curve
  const ROAD_W = 520;             // road half-width base
  const HORIZON = 0.22;           // higher sky (smaller value = higher horizon line)
  const CAMERA_Y = 170;           // camera height

  const GROUND_Y = 520;           // push "ground plane" lower -> grass fills bottom half
  const SIDEWALK_W = 140;
  const GRASS_W = 820;            // MUCH wider grass
  const ROAD_TAPER = 0.86;        // stronger convergence (higher taper)

  // Spacing controls (no clutter)
  const HOUSE_COUNT = 18;
  const HOUSE_Z_GAP = 340;        // bigger gaps = less clutter
  const LAMP_COUNT  = 14;
  const LAMP_Z_GAP  = 520;        // spaced out lamps

  // ========= Math helpers =========
  const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
  const rand = (a,b)=>a+Math.random()*(b-a);
  const randi = (a,b)=>Math.floor(rand(a,b+1));

  function project(x, y, z){
    // slightly narrower fov -> stronger depth feel
    const fov = 380;
    const scale = fov / (fov + z);
    const cx = canvas.clientWidth * 0.5;
    const cy = canvas.clientHeight * HORIZON;
    return { sx: cx + x * scale, sy: cy + (y - CAMERA_Y) * scale, s: scale };
  }

  function roadCenterX(z, t){
    // very smooth curve
    return Math.sin((t * 0.0016) + z * CURVE) * 220;
  }

  function halfRoadAtZ(z){
    // stronger taper with distance => tighter vanishing point
    const p = (z / FAR_Z);
    return ROAD_W * (1 - Math.pow(p, 0.78) * ROAD_TAPER);
  }

  // Ground height function (slight rise in distance for nicer composition)
  function groundYAtZ(z){
    // As z increases, ground rises a bit toward horizon
    return GROUND_Y - (z / FAR_Z) * 55;
  }

  // ========= Sky / Clouds / Sun haze =========
  const clouds = Array.from({length: 12}, () => ({
    x: rand(-760, 760),
    y: rand(-40, 170),
    z: rand(900, FAR_Z),
    w: rand(240, 580),
    h: rand(70, 190),
    speed: rand(0.15, 0.55),
  }));

  function drawSky(t){
    const w = canvas.clientWidth, h = canvas.clientHeight;

    // soft, pleasing sky gradient
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, "#78b9ff");
    g.addColorStop(0.35, "#bfe5ff");
    g.addColorStop(0.72, "#eaf6ff");
    g.addColorStop(1, "#f7fbff");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // subtle sun haze (top right)
    const sun = ctx.createRadialGradient(w*0.78, h*0.18, 20, w*0.78, h*0.18, Math.max(w,h)*0.55);
    sun.addColorStop(0, "rgba(255,250,220,0.75)");
    sun.addColorStop(1, "rgba(255,250,220,0)");
    ctx.fillStyle = sun;
    ctx.fillRect(0,0,w,h);

    // clouds
    ctx.save();
    ctx.fillStyle = "#ffffff";
    for(const c of clouds){
      const drift = Math.sin((t*0.001*c.speed) + c.z*0.0018) * 55;
      const p = project(c.x + drift, c.y, c.z);
      const ww = c.w * p.s;
      const hh = c.h * p.s;

      ctx.beginPath();
      ctx.ellipse(p.sx, p.sy, ww*0.44, hh*0.34, 0, 0, Math.PI*2);
      ctx.ellipse(p.sx - ww*0.26, p.sy + hh*0.06, ww*0.34, hh*0.26, 0, 0, Math.PI*2);
      ctx.ellipse(p.sx + ww*0.28, p.sy + hh*0.08, ww*0.38, hh*0.28, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  // ========= Bands (grass, sidewalk, road) =========
  function polygonBand(getLeftRightAtZ, zMax, steps, fillStyle){
    ctx.beginPath();
    for(let i=0;i<=steps;i++){
      const z = (i/steps) * zMax;
      const {lx, rx, y} = getLeftRightAtZ(z);
      const L = project(lx, y, z);
      if(i===0) ctx.moveTo(L.sx, L.sy);
      else ctx.lineTo(L.sx, L.sy);
    }
    for(let i=steps;i>=0;i--){
      const z = (i/steps) * zMax;
      const {lx, rx, y} = getLeftRightAtZ(z);
      const R = project(rx, y, z);
      ctx.lineTo(R.sx, R.sy);
    }
    ctx.closePath();
    ctx.fillStyle = fillStyle;
    ctx.fill();
  }

  function drawWorldBands(t){
    const steps = 90;

    // Grass (outer) – richer color
    polygonBand((z) => {
      const cx = roadCenterX(z, t);
      const halfRoad = halfRoadAtZ(z);
      const y = groundYAtZ(z) + 6;
      const lx = cx - (halfRoad + SIDEWALK_W + GRASS_W);
      const rx = cx + (halfRoad + SIDEWALK_W + GRASS_W);
      return { lx, rx, y };
    }, FAR_Z, steps, "#4fbf63");

    // subtle grass texture lines
    ctx.save();
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = "rgba(0,0,0,0.6)";
    ctx.lineWidth = 1;
    for(let i=0;i<24;i++){
      const y = canvas.clientHeight*(0.55 + i*0.02);
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(canvas.clientWidth,y);
      ctx.stroke();
    }
    ctx.restore();

    // Sidewalk (slightly warm gray)
    polygonBand((z) => {
      const cx = roadCenterX(z, t);
      const halfRoad = halfRoadAtZ(z);
      const y = groundYAtZ(z) + 2;
      const lx = cx - (halfRoad + SIDEWALK_W);
      const rx = cx + (halfRoad + SIDEWALK_W);
      return { lx, rx, y };
    }, FAR_Z, steps, "#e0ddd6");

    // Road
    polygonBand((z) => {
      const cx = roadCenterX(z, t);
      const halfRoad = halfRoadAtZ(z);
      const y = groundYAtZ(z);
      return { lx: cx - halfRoad, rx: cx + halfRoad, y };
    }, FAR_Z, steps, "#2a2f3c");

    // center line
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.strokeStyle = "rgba(255,255,255,0.85)";
    ctx.lineWidth = 2.6;
    ctx.setLineDash([18, 22]);
    ctx.beginPath();
    for(let i=0;i<=steps;i++){
      const z = (i/steps) * FAR_Z;
      const cx = roadCenterX(z, t);
      const p = project(cx, groundYAtZ(z), z);
      if(i===0) ctx.moveTo(p.sx, p.sy);
      else ctx.lineTo(p.sx, p.sy);
    }
    ctx.stroke();
    ctx.restore();

    // atmospheric haze near horizon (aesthetic x10)
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const hz = h * HORIZON;
    const haze = ctx.createLinearGradient(0, hz - 40, 0, hz + 260);
    haze.addColorStop(0, "rgba(255,255,255,0.20)");
    haze.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = haze;
    ctx.fillRect(0, hz - 40, w, 320);
  }

  // ========= House drawing (solid, varied) =========
  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function makeHouseStyle(){
    // nicer, cohesive palette
    const body = ["#ffd38a","#a7e7ff","#ffc0d3","#c7f2c7","#e6c8ff","#ffcfad","#fff2a8"];
    const roof = ["#ff6b6b","#ff8fb3","#6b7bff","#2f3c55","#ff9b42","#3c6b4a","#5b3a2a"];
    const trim = ["#ffffff","#2b2f3b","#fff1cc","#f7f7f7","#1b1f2a"];
    return {
      body: body[randi(0, body.length-1)],
      roof: roof[randi(0, roof.length-1)],
      trim: trim[randi(0, trim.length-1)],
      win:  "#192234",
      door: ["#7b4b2a","#2f3c55","#5a2a2a","#2a5a3b"][randi(0,3)],
      floors: randi(1,2),
      roofType: randi(0,2),
      wMul: rand(0.90, 1.20),
      hMul: rand(0.90, 1.28),
      winCols: randi(1,2),
      accent: ["#ffffff","#ffe9a6","#dff6ff","#ffd6e6"][randi(0,3)],
      hasPorch: Math.random() < 0.55,
      hasChimney: Math.random() < 0.50,
    };
  }

  function drawHouse(x, z, style){
    const yGround = groundYAtZ(z) + 8; // sit in grass (slightly lower)
    const p = project(x, yGround, z);
    const base = 250 * p.s;
    const w = base * 0.95 * style.wMul;
    const h = base * 0.86 * style.hMul;

    // subtle fog with distance
    const fog = clamp(1 - (z / FAR_Z), 0, 1);
    const shadowAlpha = 0.25 + fog * 0.25;

    // ground shadow
    ctx.save();
    ctx.globalAlpha = shadowAlpha;
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.beginPath();
    ctx.ellipse(p.sx, p.sy + 6*p.s, w*0.42, w*0.16, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // body (SOLID)
    ctx.fillStyle = style.body;
    roundRect(p.sx - w/2, p.sy - h, w, h, 14 * p.s);
    ctx.fill();

    // trim
    ctx.lineWidth = Math.max(1.2, 2.1 * p.s);
    ctx.strokeStyle = "rgba(0,0,0,0.28)";
    ctx.stroke();

    // roof
    ctx.fillStyle = style.roof;
    if(style.roofType === 0){
      ctx.beginPath();
      ctx.moveTo(p.sx - w/2, p.sy - h);
      ctx.lineTo(p.sx, p.sy - h - h*0.46);
      ctx.lineTo(p.sx + w/2, p.sy - h);
      ctx.closePath();
      ctx.fill();
    } else if(style.roofType === 1){
      roundRect(p.sx - w*0.58, p.sy - h - h*0.18, w*1.16, h*0.18, 10*p.s);
      ctx.fill();
    } else {
      ctx.beginPath();
      ctx.moveTo(p.sx - w/2, p.sy - h);
      ctx.lineTo(p.sx, p.sy - h - h*0.62);
      ctx.lineTo(p.sx + w/2, p.sy - h);
      ctx.closePath();
      ctx.fill();
    }

    // chimney (solid)
    if(style.hasChimney){
      ctx.fillStyle = "#2b2f3c";
      roundRect(p.sx + w*0.22, p.sy - h - h*0.30, w*0.12, h*0.22, 8*p.s);
      ctx.fill();
    }

    // porch
    if(style.hasPorch){
      ctx.fillStyle = style.accent;
      roundRect(p.sx - w*0.32, p.sy - h*0.10, w*0.64, h*0.12, 10*p.s);
      ctx.fill();
    }

    // door
    ctx.fillStyle = style.door;
    const dw = w*0.18, dh = h*0.30;
    roundRect(p.sx - dw/2, p.sy - dh, dw, dh, 8*p.s);
    ctx.fill();

    // windows (solid)
    ctx.fillStyle = style.win;
    const rows = style.floors + 1;
    const cols = style.winCols + 1;
    const padX = w*0.10;
    const padY = h*0.12;
    const cellW = (w - padX*2) / cols;
    const cellH = (h - padY*2) / (rows+0.4);

    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(r === rows-1 && Math.abs(c - (cols/2)) < 0.6) continue;
        const wx = (p.sx - w/2) + padX + c*cellW + cellW*0.18;
        const wy = (p.sy - h) + padY + r*cellH + cellH*0.18;
        roundRect(wx, wy, cellW*0.64, cellH*0.58, 7*p.s);
        ctx.fill();
      }
    }
  }

  // ========= Lamp drawing =========
  function drawLamp(x, z, hWorld){
    const yGround = groundYAtZ(z) + 2;
    const p = project(x, yGround, z);

    const poleW = Math.max(2, 9.5 * p.s);
    const poleH = hWorld * p.s;

    ctx.fillStyle = "#2a2a2a";
    roundRect(p.sx - poleW/2, p.sy - poleH, poleW, poleH, 10*p.s);
    ctx.fill();

    ctx.fillStyle = "#1a1a1a";
    roundRect(p.sx - poleW*1.9, p.sy - poleH - 18*p.s, poleW*3.8, 18*p.s, 8*p.s);
    ctx.fill();

    // glow
    const g = ctx.createRadialGradient(p.sx, p.sy - poleH, 2, p.sx, p.sy - poleH, 95*p.s);
    g.addColorStop(0, "rgba(255,240,190,0.92)");
    g.addColorStop(1, "rgba(255,240,190,0)");
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.ellipse(p.sx, p.sy - poleH + 10*p.s, 88*p.s, 56*p.s, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // ========= Build pools with EVEN spacing (prevents clutter + makes loop seamless) =========
  function buildEvenZPool(count, gap, startZ){
    const arr = [];
    let z = startZ;
    for(let i=0;i<count;i++){
      arr.push(z);
      z += gap;
    }
    return arr;
  }

  // Houses: two streams, left/right, staggered in Z for nicer rhythm
  const housePool = [];
  const baseHouseZ = buildEvenZPool(HOUSE_COUNT, HOUSE_Z_GAP, 320);

  for(let i=0;i<baseHouseZ.length;i++){
    const z = baseHouseZ[i];
    const side = (i % 2 === 0) ? -1 : 1;            // alternate sides
    const lane = rand(0.55, 1.05);                  // further into grass
    const style = makeHouseStyle();
    housePool.push({ z, side, lane, style });
  }

  // Lamps: evenly spaced, alternating sides
  const lampPool = [];
  const baseLampZ = buildEvenZPool(LAMP_COUNT, LAMP_Z_GAP, 520);
  for(let i=0;i<baseLampZ.length;i++){
    lampPool.push({
      z: baseLampZ[i],
      side: (i % 2 === 0) ? -1 : 1,
      lane: rand(0.10, 0.28),
      h: rand(290, 360)
    });
  }

  // ========= Scroll -> distance =========
  let targetDist = 0;
  let dist = 0;

  function computeScrollDist(){
    const rect = section.getBoundingClientRect();
    const viewH = window.innerHeight || document.documentElement.clientHeight;
    const total = section.offsetHeight - viewH;
    const scrolled = -rect.top;
    const p = total > 0 ? clamp(scrolled / total, 0, 1) : 0;
    targetDist = p * 260000;
  }

  function wrapZ(z){
    // Wrap into [0, SPAN_Z)
    z = z % SPAN_Z;
    if(z < 0) z += SPAN_Z;
    return z;
  }

  function worldXAt(z, t, side, lane, extra){
    const cx = roadCenterX(z, t);
    const halfRoad = halfRoadAtZ(z);
    const off = halfRoad + SIDEWALK_W + extra + lane * 260;
    return cx + side * off;
  }

  function tick(){
    requestAnimationFrame(tick);

    computeScrollDist();
    dist += (targetDist - dist) * 0.085;

    // This is the key: camera progress wraps on EXACT span -> seamless
    const t = dist;
    const camZ = wrapZ(t * SPEED);

    drawSky(t);
    drawWorldBands(t);

    // Collect drawables far->near for overlap
    const drawables = [];

    // Houses (stable density)
    for(const h of housePool){
      // Relative z in front of camera, wrapped
      let z = wrapZ(h.z - camZ);
      // Put objects behind camera to far distance seamlessly
      if(z < NEAR_Z) z += SPAN_Z;

      const x = worldXAt(z, t, h.side, h.lane, 170);
      drawables.push({ z, kind:"house", x, style:h.style });
    }

    // Lamps
    for(const l of lampPool){
      let z = wrapZ(l.z - camZ);
      if(z < NEAR_Z) z += SPAN_Z;

      const x = worldXAt(z, t, l.side, l.lane, 40);
      drawables.push({ z, kind:"lamp", x, h:l.h });
    }

    // Sort far -> near
    drawables.sort((a,b)=> b.z - a.z);

    for(const d of drawables){
      if(d.kind === "lamp") drawLamp(d.x, d.z, d.h);
      else drawHouse(d.x, d.z, d.style);
    }

    // Aesthetic finishing: vignette + slight color wash
    const w = canvas.clientWidth, h = canvas.clientHeight;

    // vignette
    const vg = ctx.createRadialGradient(w*0.5, h*0.62, 60, w*0.5, h*0.62, Math.max(w,h)*0.86);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, "rgba(0,0,0,0.35)");
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,w,h);

    // subtle warm wash
    ctx.save();
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = "#ffd9b3";
    ctx.fillRect(0,0,w,h);
    ctx.restore();
  }

  tick();
})();
</script>
</body>
</html>

