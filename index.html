<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Infinite Cartoon Street</title>
  <style>
    html,body{margin:0;height:100%;background:#0b0d12;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    .spacerTop,.spacerBottom{max-width:900px;margin:0 auto;padding:48px 18px;opacity:.92}
    .spacerTop h1{margin:0 0 10px 0;font-size:clamp(26px,5vw,44px);letter-spacing:-.02em}
    .spacerTop p,.spacerBottom p{margin:0;line-height:1.45;opacity:.85}

    /* Long scroll runway (practically infinite). You can increase if you want. */
    .scrollSection{height:120000px; position:relative;}

    /* Sticky viewport canvas */
    .stage{
      position:sticky; top:0;
      height:100svh; width:100%;
      overflow:hidden; background:#070a10;
    }

    canvas{display:block;width:100%;height:100%}
    .hud{
      position:absolute; left:50%; top:12px; transform:translateX(-50%);
      width:min(92vw,820px);
      padding:10px 12px; border-radius:14px;
      background:rgba(0,0,0,.35);
      backdrop-filter:blur(10px);
      -webkit-backdrop-filter:blur(10px);
      box-shadow:0 18px 60px rgba(0,0,0,.45);
      pointer-events:none;
    }
    .hud .k{font-size:12px;letter-spacing:.16em;text-transform:uppercase;opacity:.75;margin-bottom:6px}
    .hud .t{margin:0 0 4px 0;font-size:clamp(16px,3.7vw,22px);letter-spacing:-.02em}
    .hud .s{margin:0;font-size:clamp(13px,3.2vw,15px);opacity:.85;line-height:1.35}
  </style>
</head>
<body>

  <div class="spacerTop">
    <h1>Infinite Cartoon Street (Scroll Forward)</h1>
    <p>Scroll down. The street curves and houses move toward you. Houses recycle to the distance so it feels like an endless loop.</p>
  </div>

  <section class="scrollSection" id="scrollSection">
    <div class="stage" id="stage">
      <canvas id="c"></canvas>
      <div class="hud">
        <div class="k">2.5D • Canvas • Object Recycling</div>
        <h2 class="t">Scroll to move forward</h2>
        <p class="s">Next step: swap the simple house drawings with your own cartoon PNGs (AI-generated) for a premium look.</p>
      </div>
    </div>
  </section>

  <div class="spacerBottom">
    <h2 style="margin:0 0 10px 0;">After the scene</h2>
    <p>Normal content continues here.</p>
  </div>

<script>
(() => {
  const section = document.getElementById("scrollSection");
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  // DPR sizing
  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize);
  resize();

  // ====== TUNING KNOBS ======
  const FAR_Z = 2600;       // how far the street goes
  const NEAR_Z = 40;        // when houses reach this, recycle them
  const HOUSE_COUNT = 34;   // number of houses in the pool
  const SPEED = 2.2;        // forward speed multiplier from scroll
  const CURVE = 0.00055;    // road curve strength (higher = more curve)
  const ROAD_W = 520;       // base road half-width in world units
  const CAMERA_Y = 120;     // camera height
  const HORIZON = 0.30;     // horizon height ratio (0 top, 1 bottom)
  const SKY_GRAD = true;

  // Pseudo perspective projection
  function project(x, y, z){
    // z grows smaller as it gets near; scale increases
    const fov = 420;
    const scale = fov / (fov + z);
    const cx = canvas.clientWidth * 0.5;
    const cy = canvas.clientHeight * HORIZON;
    return {
      sx: cx + x * scale,
      sy: cy + (y - CAMERA_Y) * scale,
      s: scale
    };
  }

  // Street center curve as function of z (sine-ish)
  function roadCenterX(z, t){
    // Use a slow oscillation based on distance traveled (t)
    return Math.sin((t * 0.002) + z * CURVE) * 220;
  }

  // Simple “cartoon house” draw (replace later with images)
  function drawHouse(x, baseY, z, side, t){
    const p = project(x, baseY, z);
    const size = 220 * p.s;              // base size scaled by perspective
    const w = size * 0.9;
    const h = size * 0.8;

    // Fade far houses slightly
    const fog = Math.max(0, Math.min(1, 1 - (z / FAR_Z)));
    const alpha = 0.22 + fog * 0.78;

    // Small wobble so it feels alive
    const wob = Math.sin((t*0.01) + z*0.01) * 2;

    // Body
    ctx.globalAlpha = alpha;
    ctx.fillStyle = side > 0 ? "rgba(255,210,120,1)" : "rgba(140,220,255,1)";
    roundRect(p.sx - w/2, p.sy - h, w, h, 10 * p.s);
    ctx.fill();

    // Roof
    ctx.fillStyle = "rgba(255,120,140,1)";
    ctx.beginPath();
    ctx.moveTo(p.sx - w/2, p.sy - h);
    ctx.lineTo(p.sx, p.sy - h - h*0.45 + wob);
    ctx.lineTo(p.sx + w/2, p.sy - h);
    ctx.closePath();
    ctx.fill();

    // Windows
    ctx.fillStyle = "rgba(20,30,45,0.85)";
    const ww = w*0.18, wh = h*0.18, gap = w*0.12;
    for(let r=0;r<2;r++){
      for(let c=0;c<2;c++){
        const wx = p.sx - gap + c*(gap*2) - ww/2;
        const wy = p.sy - h*0.70 + r*(wh*1.45);
        roundRect(wx, wy, ww, wh, 6 * p.s);
        ctx.fill();
      }
    }

    // Outline
    ctx.globalAlpha = alpha * 0.55;
    ctx.lineWidth = Math.max(1, 2 * p.s);
    ctx.strokeStyle = "rgba(0,0,0,0.5)";
    roundRect(p.sx - w/2, p.sy - h, w, h, 10 * p.s);
    ctx.stroke();

    ctx.globalAlpha = 1;
  }

  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  // House pool: each house has a z position and which side
  const houses = Array.from({length: HOUSE_COUNT}, (_, i) => ({
    z: (i / HOUSE_COUNT) * FAR_Z + 60,
    side: (i % 2 === 0) ? -1 : 1,
    lane: Math.random() * 0.6 + 0.25,  // how far from road edge (0..1)
    y: 240 + Math.random() * 50        // slight height variance
  }));

  // Smooth scroll progress -> distance traveled
  let targetDist = 0;
  let dist = 0;

  function computeScrollDist(){
    const rect = section.getBoundingClientRect();
    const viewH = window.innerHeight || document.documentElement.clientHeight;
    const total = section.offsetHeight - viewH;
    const scrolled = -rect.top;
    const p = total > 0 ? Math.max(0, Math.min(1, scrolled / total)) : 0;

    // Map 0..1 scroll progress into a large travel distance.
    // This gives “endless” feel because visuals loop; scroll length is just runway.
    targetDist = p * 180000; // increase for more forward travel per section
  }

  function drawSky(){
    if(!SKY_GRAD) return;
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,"#0b1020");
    g.addColorStop(0.55,"#070a12");
    g.addColorStop(1,"#05060a");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
  }

  function drawRoad(t){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const horizonY = h * HORIZON;

    // Road polygon by sampling along z
    const steps = 70;
    ctx.beginPath();

    for(let i=0;i<=steps;i++){
      const z = (i/steps) * FAR_Z;
      const cx = roadCenterX(z, t);

      const halfW = ROAD_W * (1 - (z / FAR_Z) * 0.78);
      const left = project(cx - halfW, 420, z);
      if(i===0) ctx.moveTo(left.sx, left.sy);
      else ctx.lineTo(left.sx, left.sy);
    }

    for(let i=steps;i>=0;i--){
      const z = (i/steps) * FAR_Z;
      const cx = roadCenterX(z, t);

      const halfW = ROAD_W * (1 - (z / FAR_Z) * 0.78);
      const right = project(cx + halfW, 420, z);
      ctx.lineTo(right.sx, right.sy);
    }

    ctx.closePath();
    ctx.fillStyle = "#0f1423";
    ctx.fill();

    // Road center line dashes
    ctx.save();
    ctx.globalAlpha = 0.5;
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 3;
    ctx.setLineDash([14, 18]);

    ctx.beginPath();
    for(let i=0;i<=steps;i++){
      const z = (i/steps) * FAR_Z;
      const cx = roadCenterX(z, t);
      const p = project(cx, 420, z);
      if(i===0) ctx.moveTo(p.sx, p.sy);
      else ctx.lineTo(p.sx, p.sy);
    }
    ctx.stroke();
    ctx.restore();

    // Fog at horizon
    const fogH = Math.max(160, h*0.35);
    const fog = ctx.createLinearGradient(0, horizonY - fogH*0.2, 0, horizonY + fogH);
    fog.addColorStop(0, "rgba(255,255,255,0.05)");
    fog.addColorStop(1, "rgba(5,6,10,0)");
    ctx.fillStyle = fog;
    ctx.fillRect(0, horizonY - fogH*0.2, w, fogH);
  }

  function tick(){
    requestAnimationFrame(tick);

    computeScrollDist();

    // smooth distance
    dist += (targetDist - dist) * 0.08;

    // Loop “forward world” distance so it never ends visually
    const t = dist % 1000000;

    // Clear
    drawSky();

    // Draw road
    drawRoad(t);

    // Update + draw houses (far to near for correct overlap)
    // Determine their world z relative to camera progress
    const camZ = (t * SPEED) % FAR_Z;

    // Sort by z far->near
    const ordered = houses.slice().sort((a,b) => (b.z - a.z));

    for(const h of ordered){
      // Relative z toward camera
      let z = h.z - camZ;
      if(z < 0) z += FAR_Z; // wrap

      // When very near, recycle the house to the far distance with new style vars
      // (This helps “new houses pop up” feeling.)
      if(z < NEAR_Z){
        h.z = camZ + FAR_Z - (Math.random()*240 + 120);
        h.side = (Math.random() < 0.5) ? -1 : 1;
        h.lane = Math.random() * 0.65 + 0.2;
        h.y = 240 + Math.random() * 70;
        z = h.z - camZ;
      }

      // Place houses off the road edge + curved center
      const center = roadCenterX(z, t);
      const edge = ROAD_W * (1 - (z / FAR_Z) * 0.78);
      const offset = edge + 220 + h.lane * 220;
      const x = center + (h.side * offset);

      drawHouse(x, h.y, z, h.side, t);
    }

    // Subtle vignette
    const w = canvas.clientWidth, hgt = canvas.clientHeight;
    const g = ctx.createRadialGradient(w*0.5, hgt*0.62, 60, w*0.5, hgt*0.62, Math.max(w,hgt)*0.75);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,0.55)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,hgt);
  }

  tick();
})();
</script>
</body>
</html>
