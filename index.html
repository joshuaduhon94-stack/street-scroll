<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scroll Street</title>
  <style>
    :root{
      --scene-h: 100svh;
      --travel: 3200px;         /* TOTAL "WALK" DISTANCE (SCROLL LENGTH) */
      --max-tilt: 1.5deg;       /* SMALL PERSPECTIVE TILT */
      --ease: 0.10;             /* LOWER = SLOWER/SOOTHER, HIGHER = SNAPPY */
    }

    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background:#0b0d12;
      color:#fff;
      overflow-x:hidden;
    }

    /* Spacer content before/after so you see the transition */
    .top, .bottom{
      padding: 56px 18px;
      max-width: 900px;
      margin: 0 auto;
      opacity: .95;
    }

    .top h1{
      font-size: clamp(28px, 5vw, 44px);
      margin: 0 0 10px 0;
      letter-spacing: -0.02em;
    }
    .top p{ margin:0; line-height:1.45; opacity:.85; }

    /* The long scroll section */
    .scroll-section{
      position: relative;
      height: calc(var(--scene-h) + var(--travel));
    }

    /* Sticky scene pinned to viewport while you "walk" */
    .scene{
      position: sticky;
      top: 0;
      height: var(--scene-h);
      width: 100%;
      overflow: hidden;
      touch-action: pan-y;
      background: #070a10;
    }

    /* Subtle vignette + haze to sell depth */
    .vignette{
      pointer-events:none;
      position:absolute;
      inset:0;
      background:
        radial-gradient(120% 85% at 50% 60%, rgba(0,0,0,0) 45%, rgba(0,0,0,.55) 100%),
        linear-gradient(to bottom, rgba(0,0,0,.20), rgba(0,0,0,.65));
      mix-blend-mode: multiply;
      z-index: 50;
    }

    /* This container gets small perspective tilt and "forward" feel */
    .world{
      position:absolute;
      inset:0;
      transform-style: preserve-3d;
      will-change: transform;
    }

    /* Background "street" layer */
    .street{
      position:absolute;
      inset:-12% -12% -20% -12%;
      background:
        /* [REPLACE_THIS] Put your street image here if you have one */
        /* Example: background-image: url("street.jpg"); */
        linear-gradient(to bottom, #0e1421, #090c14 65%, #05060a),
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,0.10) 0px,
          rgba(255,255,255,0.10) 2px,
          rgba(255,255,255,0.00) 12px,
          rgba(255,255,255,0.00) 64px
        );
      background-blend-mode: screen;
      background-size: cover;
      background-position: center;
      filter: saturate(1.05) contrast(1.08);
      transform: translate3d(0,0,0) scale(1.12);
      will-change: transform, filter;
      z-index: 1;
    }

    /* Midground: buildings silhouettes */
    .buildings{
      position:absolute;
      inset:-6% -6% -10% -6%;
      background:
        linear-gradient(to bottom, rgba(0,0,0,0.0), rgba(0,0,0,.55)),
        radial-gradient(40% 70% at 15% 30%, rgba(40,80,255,.22), rgba(0,0,0,0) 60%),
        radial-gradient(45% 70% at 85% 28%, rgba(255,60,180,.18), rgba(0,0,0,0) 62%),
        linear-gradient(to top, rgba(10,12,18,.95), rgba(10,12,18,.15) 45%, rgba(0,0,0,0));
      mask-image:
        linear-gradient(to bottom, rgba(0,0,0,1), rgba(0,0,0,1)),
        radial-gradient(140% 90% at 50% 50%, rgba(0,0,0,1), rgba(0,0,0,0) 70%);
      mix-blend-mode: screen;
      opacity: .9;
      transform: translate3d(0,0,0) scale(1.06);
      will-change: transform, opacity;
      z-index: 5;
    }

    /* Foreground: poles + signs (simple SVG-ish blocks) */
    .foreground{
      position:absolute;
      inset:0;
      z-index: 20;
      pointer-events:none;
    }
    .pole{
      position:absolute;
      top: -10%;
      bottom: -10%;
      width: 3.2vw;
      max-width: 18px;
      min-width: 10px;
      background: linear-gradient(to bottom, rgba(255,255,255,.25), rgba(255,255,255,.05));
      opacity: .55;
      filter: blur(.2px);
      border-radius: 8px;
      transform: translate3d(0,0,0);
      will-change: transform, opacity;
    }
    .pole.left{ left: 6vw; }
    .pole.right{ right: 7vw; }

    .sign{
      position:absolute;
      width: 26vw;
      max-width: 160px;
      min-width: 110px;
      height: 9vh;
      max-height: 90px;
      min-height: 54px;
      border-radius: 14px;
      background: linear-gradient(135deg, rgba(255,255,255,.22), rgba(255,255,255,.05));
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      opacity: .7;
      transform: translate3d(0,0,0);
      will-change: transform, opacity;
    }
    .sign.one{ left: 10vw; top: 16vh; }
    .sign.two{ right: 10vw; top: 24vh; }

    /* Floating dust/fog */
    .fog{
      position:absolute;
      inset:-10% -10% -10% -10%;
      background:
        radial-gradient(60% 40% at 50% 70%, rgba(255,255,255,.08), rgba(255,255,255,0) 70%),
        radial-gradient(40% 30% at 30% 40%, rgba(255,255,255,.05), rgba(255,255,255,0) 65%),
        radial-gradient(45% 35% at 70% 35%, rgba(255,255,255,.04), rgba(255,255,255,0) 70%);
      filter: blur(10px);
      opacity: .65;
      mix-blend-mode: screen;
      will-change: transform, opacity;
      z-index: 30;
    }

    /* Center copy that stays readable */
    .hud{
      position:absolute;
      left: 50%;
      top: 12vh;
      transform: translateX(-50%);
      text-align:center;
      z-index: 40;
      width: min(92vw, 720px);
      padding: 12px 14px;
      border-radius: 16px;
      background: rgba(0,0,0,.25);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 14px 50px rgba(0,0,0,.35);
    }
    .hud .kicker{
      font-size: 12px;
      letter-spacing: .18em;
      text-transform: uppercase;
      opacity: .78;
      margin-bottom: 8px;
    }
    .hud .title{
      font-size: clamp(20px, 4.5vw, 34px);
      margin: 0 0 6px 0;
      letter-spacing: -0.02em;
    }
    .hud .sub{
      margin:0;
      opacity:.85;
      line-height:1.4;
      font-size: clamp(14px, 3.4vw, 16px);
    }

    /* Reduce motion for accessibility */
    @media (prefers-reduced-motion: reduce){
      :root{ --ease: 1; }
      .street,.buildings,.pole,.sign,.fog,.world{ transition:none !important; }
    }
  </style>
</head>

<body>
  <div class="top">
    <h1>Street Scroll Demo</h1>
    <p>Scroll down. The scene pins to the screen and simulates moving forward down a street using layered parallax.</p>
  </div>

  <section class="scroll-section" id="streetSection">
    <div class="scene" id="scene">
      <div class="world" id="world">
        <div class="street" id="street"></div>
        <div class="buildings" id="buildings"></div>

        <div class="foreground">
          <div class="pole left" id="poleL"></div>
          <div class="pole right" id="poleR"></div>
          <div class="sign one" id="sign1"></div>
          <div class="sign two" id="sign2"></div>
        </div>

        <div class="fog" id="fog"></div>

        <div class="hud">
          <div class="kicker">Mobile-first • Sticky + Parallax</div>
          <h2 class="title">Scroll to “walk forward”</h2>
          <p class="sub">Replace the street background with your own image for a realistic look.</p>
        </div>

        <div class="vignette"></div>
      </div>
    </div>
  </section>

  <div class="bottom">
    <h2 style="margin:0 0 10px 0;">Next section</h2>
    <p style="margin:0; opacity:.85; line-height:1.45;">
      This is normal page content after the scene.
    </p>
  </div>

  <script>
    (() => {
      const section = document.getElementById("streetSection");
      const scene   = document.getElementById("scene");

      const el = {
        world:     document.getElementById("world"),
        street:    document.getElementById("street"),
        buildings: document.getElementById("buildings"),
        poleL:     document.getElementById("poleL"),
        poleR:     document.getElementById("poleR"),
        sign1:     document.getElementById("sign1"),
        sign2:     document.getElementById("sign2"),
        fog:       document.getElementById("fog"),
      };

      // Progress smoothing
      let targetP = 0;     // target progress 0..1
      let smoothP = 0;     // smoothed progress 0..1
      let ticking = false;

      const clamp01 = (n) => Math.max(0, Math.min(1, n));

      function computeProgress() {
        const rect = section.getBoundingClientRect();
        const viewH = window.innerHeight || document.documentElement.clientHeight;
        const total = section.offsetHeight - viewH;
        const scrolled = -rect.top;
        targetP = total > 0 ? clamp01(scrolled / total) : 0;
      }

      function render() {
        ticking = false;

        const ease = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--ease")) || 0.10;
        smoothP += (targetP - smoothP) * ease;

        // Convert progress into "forward travel"
        const travelPx = smoothP * 900; // HOW FAR THE STREET LAYER MOVES (TUNE THIS)

        // Small perspective tilt for depth (subtle)
        const tilt = (smoothP - 0.5) * 2 * (parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--max-tilt")) || 1.5);

        el.world.style.transform = `perspective(900px) rotateX(${tilt}deg)`;

        // Parallax layer speeds (foreground moves more)
        el.street.style.transform    = `translate3d(0, ${-travelPx}px, 0) scale(1.12)`;
        el.buildings.style.transform = `translate3d(0, ${-travelPx * 0.55}px, 0) scale(1.06)`;

        // Foreground elements slide faster, selling forward motion
        const fg = -travelPx * 0.95;
        el.poleL.style.transform = `translate3d(0, ${fg}px, 0)`;
        el.poleR.style.transform = `translate3d(0, ${fg}px, 0)`;
        el.sign1.style.transform = `translate3d(0, ${fg * 0.85}px, 0)`;
        el.sign2.style.transform = `translate3d(0, ${fg * 0.78}px, 0)`;

        // Fog increases slightly as you go "deeper"
        el.fog.style.transform = `translate3d(0, ${-travelPx * 0.35}px, 0)`;
        el.fog.style.opacity = (0.45 + smoothP * 0.35).toFixed(3);

        // Keep animating until close enough to target
        if (Math.abs(targetP - smoothP) > 0.0008) {
          requestTick();
        }
      }

      function requestTick(){
        if (!ticking){
          ticking = true;
          requestAnimationFrame(render);
        }
      }

      // Only animate while section is near viewport for performance
      let inView = false;
      const io = new IntersectionObserver((entries) => {
        inView = entries[0].isIntersecting;
        if (inView){
          computeProgress();
          requestTick();
        }
      }, { root: null, threshold: 0, rootMargin: "200px 0px 200px 0px" });

      io.observe(scene);

      // Update on scroll/resize
      window.addEventListener("scroll", () => {
        if (!inView) return;
        computeProgress();
        requestTick();
      }, { passive: true });

      window.addEventListener("resize", () => {
        computeProgress();
        requestTick();
      });

      // Initial
      computeProgress();
      requestTick();
    })();
  </script>
</body>
</html>
